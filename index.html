<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>MatchMind: –§–æ—Ç–æ–ü–∞–º—è—Ç—å ‚Äî v1.0</title>

  <!-- Telegram WebApp SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      background: #eef1f6;
      padding: 12px;
    }

    .game {
      width: 100%;
      max-width: 500px;
      padding: 20px;
      border-radius: 20px;
      background: #eef1f6;
      box-shadow: 10px 10px 20px #d6dae0, -10px -10px 20px #fff;
      text-align: center;
    }

    h1 {
      font-size: 22px;
      margin-bottom: 16px;
      color: #2c3e50;
      line-height: 1.3;
    }

    .controls-start {
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin-bottom: 16px;
    }

    .mode-buttons {
      display: flex;
      gap: 8px;
      justify-content: center;
      flex-wrap: wrap;
    }

    @keyframes warnBlink {
      0%, 50%, 100% { box-shadow: 6px 6px 12px #cfd3da, -6px -6px 12px #fff; }
      25%, 75% { box-shadow: 0 0 0 3px rgba(255, 140, 0, 1); }
    }

    @keyframes inputBounce {
      0% { transform: translateY(0); }
      30% { transform: translateY(-6px); }
      55% { transform: translateY(0); }
      75% { transform: translateY(-3px); }
      100% { transform: translateY(0); }
    }

    button {
      padding: 14px 18px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 14px;
      background: #eef1f6;
      cursor: pointer;
      box-shadow: 6px 6px 12px #cfd3da, -6px -6px 12px #fff;
      transition: transform 0.12s ease, box-shadow 0.12s ease;
      min-width: 90px;
      touch-action: manipulation;
    }

    button:active {
      transform: scale(0.95);
      box-shadow: inset 4px 4px 8px #cfd3da, inset -4px -4px 8px #fff;
    }

    button.warn {
      animation: warnBlink 0.8s ease-in-out;
    }

    button.active {
      outline: 3px solid #4caf50;
      outline-offset: 2px;
    }

    input {
      width: 80px;
      padding: 10px;
      font-size: 18px;
      text-align: center;
      border: none;
      border-radius: 12px;
      background: #eef1f6;
      box-shadow: inset 4px 4px 8px #cfd3da, inset -4px -4px 8px #fff;
      transition: box-shadow 0.25s, background-color 0.25s;
    }

    input.input-warn {
      background: #fff3e0;
      box-shadow: 0 0 0 3px rgba(255, 140, 0, 0.9);
      animation: inputBounce 0.35s ease-out;
    }

    .field {
      position: relative;
      height: 280px;
      padding: 10px;
      border-radius: 18px;
      background: #eef1f6;
      box-shadow: inset 6px 6px 12px #cfd3da, inset -6px -6px 12px #fff;
      overflow: hidden;
      margin: 12px auto;
    }

    @media (min-width: 481px) {
      .field { height: 320px; }
    }

    .hidden { display: none !important; }

    .timer {
      font-size: 20px;
      color: #e74c3c;
      margin: 14px 0;
      font-weight: 600;
    }

    .object {
      position: absolute;
      animation-fill-mode: both;
      animation-timing-function: cubic-bezier(0.22, 0.61, 0.36, 1);
      transform: rotate(var(--rot, 0deg));
      cursor: pointer;
      touch-action: manipulation;
    }

    .object.selected {
      outline: 3px solid #4caf50;
      outline-offset: 2px;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.35);
    }

    .figure {
      box-shadow: 0 6px 10px rgba(0, 0, 0, 0.25), inset 0 2px 3px rgba(255, 255, 255, 0.6), inset 0 -3px 6px rgba(0, 0, 0, 0.25);
    }

    .figure::after {
      content: '';
      position: absolute;
      inset: 3px;
      border-radius: inherit;
      background: linear-gradient(to bottom right, rgba(255, 255, 255, 0.35), transparent);
      pointer-events: none;
    }

    .figure.triangle {
      box-shadow: none;
      filter: drop-shadow(0 6px 8px rgba(0, 0, 0, 0.35));
    }

    .from-top { animation-name: fromTop; }
    .from-bottom { animation-name: fromBottom; }
    .from-left { animation-name: fromLeft; }
    .from-right { animation-name: fromRight; }

    @keyframes fromTop {
      0% { transform: translateY(-120px) rotate(var(--rot)) scale(0.9); opacity: 0; }
      80% { transform: translateY(0) rotate(var(--rot)) scale(1.05); opacity: 1; }
      100% { transform: translateY(0) rotate(var(--rot)) scale(1); }
    }
    @keyframes fromBottom { /* –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ */ }
    @keyframes fromLeft { /* –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ */ }
    @keyframes fromRight { /* –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ */ }

    .match {
      width: 94px;
      height: 6px;
      border-radius: 4px;
      background: linear-gradient(#deb887, #cfa36a 40%, #b88952);
    }
    .match::after {
      content: '';
      position: absolute;
      right: -6px;
      top: -4px;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: radial-gradient(circle, #ff6b6b, #b22222);
    }

    .number {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: #fff;
      color: #222;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: 700;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    @keyframes pop {
      0% { transform: scale(0.85); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }

    .instruction-step {
      margin: 12px 0;
      font-size: 18px;
      color: #2c3e50;
      min-height: 24px;
      font-weight: 500;
    }

    .info-section {
      margin-top: 20px;
      padding: 14px;
      background: #f8f9fa;
      border-radius: 16px;
      box-shadow: inset 2px 2px 4px #d1d5db, inset -2px -2px 4px #ffffff;
      text-align: justify;
      font-size: 14px;
      color: #495057;
      line-height: 1.5;
    }

    .info-section h3 {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 16px;
      font-weight: 600;
      color: #2c3e50;
      text-align: center;
    }

    .info-section p {
      margin: 8px 0;
    }

    #instructions {
      font-size: 16px;
      color: #34495e;
      line-height: 1.4;
      margin: 6px 0;
    }

    .game p {
      margin: 8px 0;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <div class="game">
    <h1>üß† MatchMind: –§–æ—Ç–æ–ü–∞–º—è—Ç—å</h1>

    <div id="startScreen" class="controls-start">
      <p>‚úèÔ∏è –ü–æ–¥–≥–æ—Ç–æ–≤—å: –ª–∏—Å—Ç –±—É–º–∞–≥–∏ –∏ —Ä—É—á–∫—É</p>
      <div style="display: flex; justify-content: center; align-items: center; gap: 12px;">
        <input type="number" id="count" min="1" max="20" value="4" inputmode="numeric" pattern="[0-9]*" />
        <button id="startBtn">–ù–∞—á–∞—Ç—å</button>
      </div>
      <div class="mode-buttons">
        <button data-mode="matches">–°–ø–∏—á–∫–∏</button>
        <button data-mode="figures">–§–∏–≥—É—Ä—ã</button>
        <button data-mode="numbers">–ß–∏—Å–ª–∞</button>
      </div>

      <div id="instructions">
        üß† –ó–∞–ø–æ–º–Ω–∏ –æ–±—ä–µ–∫—Ç—ã<br>
        üìù –ù–∞—Ä–∏—Å—É–π –∏—Ö –Ω–∞ –±—É–º–∞–≥–µ<br>
        üëÄ –ù–∞–∂–º–∏ ¬´–ü–æ–∫–∞–∑–∞—Ç—å¬ª –∏ –æ—Ç–º–µ—Ç—å —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è
      </div>

      <div class="info-section">
        <h3>‚ÑπÔ∏è –û–± –∏–≥—Ä–µ</h3>
        <p>–ù–∞—à —Ç—Ä–µ–Ω–∞–∂—ë—Ä –ø–æ—Å—Ç—Ä–æ–µ–Ω –Ω–∞ –Ω–∞—É—á–Ω–æ –¥–æ–∫–∞–∑–∞–Ω–Ω—ã—Ö –ø—Ä–∏–Ω—Ü–∏–ø–∞—Ö —Ä–∞–±–æ—Ç—ã –º–æ–∑–≥–∞. –ò–Ω–Ω–æ–≤–∞—Ü–∏–æ–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥, –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–π –Ω–∞ –≤–∏–∑—É–∞–ª—å–Ω–æ–º –ø–µ—Ä–µ–Ω–æ—Å–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ —Å —ç–∫—Ä–∞–Ω–∞ –Ω–∞ –±—É–º–∞–≥—É, –∞–∫—Ç–∏–≤–∏–∑–∏—Ä—É–µ—Ç –∫–ª—é—á–µ–≤—ã–µ –º–µ—Ö–∞–Ω–∏–∑–º—ã –∑–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –∏ —Ä–∞–∑–≤–∏–≤–∞–µ—Ç —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫—É—é –ø–∞–º—è—Ç—å.</p>
        <p>–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –º–µ—Ç–æ–¥–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç—Å—è –±—ã—Å—Ç—Ä—ã–º –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º: —É–∂–µ —á–µ—Ä–µ–∑ –Ω–µ–¥–µ–ª—é —Ä–µ–≥—É–ª—è—Ä–Ω—ã—Ö —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫ –≤—ã –∑–∞–º–µ—Ç–∏—Ç–µ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –∫ –∑–∞–ø–æ–º–∏–Ω–∞–Ω–∏—é.</p>
        <p>–í –æ—Ç–ª–∏—á–∏–µ –æ—Ç –æ–±—ã—á–Ω—ã—Ö –∏–≥—Ä –Ω–∞ –ø–∞–º—è—Ç—å, –Ω–∞—à–∞ —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç —Ü–µ–ª–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—É—é —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å –æ–±—É—á–µ–Ω–∏—è –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏–≤–Ω—É—é —Ä–∞–±–æ—Ç—É –Ω–∞–¥ —Ä–∞–∑–≤–∏—Ç–∏–µ–º –≤–∞—à–∏—Ö –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã—Ö —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π.</p>
      </div>
    </div>

    <div id="step1" class="instruction-step hidden">üß† –ó–∞–ø–æ–º–Ω–∏ –æ–±—ä–µ–∫—Ç—ã</div>
    <div id="timer" class="timer hidden"></div>
    <div id="field" class="field hidden"></div>
    <div id="step2" class="instruction-step hidden">üìù –ù–∞—Ä–∏—Å—É–π –∏—Ö –Ω–∞ –±—É–º–∞–≥–µ</div>

    <div style="margin-top: 12px">
      <button id="showBtn" class="hidden">–ü–æ–∫–∞–∑–∞—Ç—å</button>
    </div>

    <div id="step3" class="instruction-step hidden">üëÄ –û—Ç–º–µ—Ç—å —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è</div>
    <button id="resetBtn" class="hidden" style="margin-top: 14px">–ù–æ–≤–∞—è –ø–æ–ø—ã—Ç–∫–∞</button>

    <div id="result" class="hidden" style="margin-top: 12px; font-size: 18px; font-weight: 600;"></div>
    <div id="achievement" class="hidden" style="margin-top: 8px; font-size: 18px; font-weight: 600;"></div>
  </div>

  <script>
    const SAFE = 12;
    const CLICK_TOLERANCE = 16;
    const animDirs = ['from-top', 'from-bottom', 'from-left', 'from-right'];
    const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#e67e22'];

    // DOM elements
    const field = document.getElementById('field');
    const startBtn = document.getElementById('startBtn');
    const showBtn = document.getElementById('showBtn');
    const resetBtn = document.getElementById('resetBtn');
    const timerEl = document.getElementById('timer');
    const result = document.getElementById('result');
    const achievement = document.getElementById('achievement');
    const countInput = document.getElementById('count');
    const modeBtns = document.querySelectorAll('.mode-buttons button');
    const step1 = document.getElementById('step1');
    const step2 = document.getElementById('step2');
    const step3 = document.getElementById('step3');
    const startScreen = document.getElementById('startScreen');

    let mode = null, total = 0, selected = 0, timer;

    // Input validation
    countInput.addEventListener('input', () => {
      let v = Math.min(20, Math.max(1, parseInt(countInput.value) || 1));
      countInput.value = v;
    });

    // Mode selection
    modeBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        modeBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        mode = btn.dataset.mode;
      });
    });

    // Start game
    startBtn.addEventListener('click', () => {
      const countValue = +countInput.value;
      if (!mode) {
        modeBtns.forEach(b => {
          b.classList.remove('warn');
          void b.offsetWidth;
          b.classList.add('warn');
        });
        return;
      }

      total = countValue;
      selected = 0;

      startScreen.classList.add('hidden');
      step1.classList.remove('hidden');
      field.classList.remove('hidden');
      timerEl.classList.remove('hidden');

      generate();
      startTimer();
    });

    function startTimer() {
      let t = 15;
      timerEl.textContent = `–û—Å—Ç–∞–ª–æ—Å—å: ${t} —Å–µ–∫`;
      timer = setInterval(() => {
        t--;
        timerEl.textContent = `–û—Å—Ç–∞–ª–æ—Å—å: ${t} —Å–µ–∫`;
        if (t <= 0) {
          clearInterval(timer);
          step1.classList.add('hidden');
          field.classList.add('hidden');
          timerEl.classList.add('hidden');
          step2.classList.remove('hidden');
          step3.classList.remove('hidden');
          showBtn.classList.remove('hidden');
        }
      }, 1000);
    }

    showBtn.addEventListener('click', () => {
      step2.classList.add('hidden');
      step3.classList.add('hidden');
      showBtn.classList.add('hidden');
      resetBtn.classList.remove('hidden');
      field.classList.remove('hidden');
      field.classList.add('check');
      updateResult();
    });

    resetBtn.addEventListener('click', () => {
      field.innerHTML = '';
      field.className = 'field hidden';
      timerEl.className = 'timer hidden';
      step1.className = 'instruction-step hidden';
      step2.className = 'instruction-step hidden';
      step3.className = 'instruction-step hidden';
      showBtn.className = 'hidden';
      resetBtn.className = 'hidden';
      result.className = 'hidden';
      achievement.className = 'hidden';
      startScreen.classList.remove('hidden');
      mode = null;
      total = 0;
      selected = 0;
      clearInterval(timer);
      modeBtns.forEach(b => b.classList.remove('active'));
    });

    field.addEventListener('click', e => {
      if (!field.classList.contains('check')) return;
      const rect = field.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      field.querySelectorAll('.object:not(.selected)').forEach(el => {
        const r = el.getBoundingClientRect();
        const elX = r.left - rect.left;
        const elY = r.top - rect.top;
        const w = r.width + CLICK_TOLERANCE * 2;
        const h = r.height + CLICK_TOLERANCE * 2;
        const x = elX - CLICK_TOLERANCE;
        const y = elY - CLICK_TOLERANCE;

        if (clickX >= x && clickX <= x + w && clickY >= y && clickY <= y + h) {
          el.classList.add('selected');
          selected++;
          updateResult();
        }
      });
    });

    function updateResult() {
      result.textContent = `–û—Ç–º–µ—á–µ–Ω–æ: ${selected} –∏–∑ ${total}`;
      result.classList.remove('hidden');
      updateAchievement();
    }

    function updateAchievement() {
      achievement.style.animation = 'none';
      void achievement.offsetWidth;
      achievement.style.animation = 'pop 0.35s ease';

      const ratio = selected / total;
      achievement.textContent =
        ratio === 1 ? 'üß†‚ú® –ò–¥–µ–∞–ª—å–Ω–æ!'
        : ratio >= 0.8 ? 'üß†üëç –û—Ç–ª–∏—á–Ω–æ!'
        : ratio >= 0.5 ? 'üß† –ù–µ–ø–ª–æ—Ö–æ'
        : '';
      achievement.classList.remove('hidden');
    }

    function intersects(a, b) {
      return !(
        a.right <= b.left ||
        b.right <= a.left ||
        a.bottom <= b.top ||
        b.bottom <= a.top
      );
    }

    function generate() {
      field.innerHTML = '';
      const fw = field.clientWidth;
      const fh = field.clientHeight;
      const padding = 12;
      let placed = [];
      let attempts = 0;

      while (placed.length < total && attempts < 3000) {
        attempts++;
        const box = createBox();
        field.appendChild(box.el);

        const x = padding + Math.random() * (fw - box.el.offsetWidth - padding * 2);
        const y = padding + Math.random() * (fh - box.el.offsetHeight - padding * 2);
        box.el.style.left = `${x}px`;
        box.el.style.top = `${y}px`;

        const r2 = box.el.getBoundingClientRect();
        const fr = field.getBoundingClientRect();

        if (
          r2.left < fr.left + SAFE ||
          r2.top < fr.top + SAFE ||
          r2.right > fr.right - SAFE ||
          r2.bottom > fr.bottom - SAFE ||
          placed.some(p => intersects(r2, p))
        ) {
          field.removeChild(box.el);
          continue;
        }

        placed.push(r2);
        box.el.classList.add(animDirs[Math.floor(Math.random() * 4)]);
        box.el.style.animationDuration = `${0.4 + Math.random() * 0.6}s`;
        box.el.style.animationDelay = `${placed.length * 80}ms`;
      }

      if (placed.length < total) generate();
    }

    function createBox() {
      const el = document.createElement('div');
      el.classList.add('object');

      if (mode === 'matches') {
        el.classList.add('match');
        el.style.setProperty('--rot', `${Math.random() * 360}deg`);
      }

      if (mode === 'numbers') {
        el.classList.add('number');
        el.textContent = Math.floor(Math.random() * 10);
      }

      if (mode === 'figures') {
        el.classList.add('figure');
        const shape = ['square', 'circle', 'triangle'][Math.floor(Math.random() * 3)];
        const color = colors[Math.floor(Math.random() * colors.length)];

        if (shape === 'triangle') {
          el.classList.add('triangle');
          el.style.width = '0';
          el.style.height = '0';
          el.style.borderLeft = '30px solid transparent';
          el.style.borderRight = '30px solid transparent';
          el.style.borderBottom = `60px solid ${color}`;
        } else {
          el.style.width = '60px';
          el.style.height = '60px';
          el.style.background = color;
          if (shape === 'circle') el.style.borderRadius = '50%';
        }
      }

      return { el };
    }

    // Telegram WebApp init
    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
      Telegram.WebApp.expand();
      Telegram.WebApp.disableVerticalSwipes();
      Telegram.WebApp.ready();
    }
  </script>
</body>
</html>
